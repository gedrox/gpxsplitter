// Generated by CoffeeScript 1.7.1
var App, Divider, DownloadLinks, EleView, FileInput, GPXView, HRLine, TinySummary, a, button, div, form, g, h1, h2, input, p, path, rect, span, svg, _ref;

_ref = React.DOM, div = _ref.div, form = _ref.form, input = _ref.input, p = _ref.p, h1 = _ref.h1, h2 = _ref.h2, a = _ref.a, button = _ref.button, svg = _ref.svg, rect = _ref.rect, path = _ref.path, g = _ref.g, span = _ref.span;

App = React.createClass({
  getInitialState: function() {
    return {
      xml: null,
      cutoff: null,
      updateCutoff: this.updateCutoff,
      updateXML: this.updateXML
    };
  },
  updateCutoff: function(newCutoff) {
    return this.setState({
      cutoff: newCutoff
    });
  },
  updateXML: function(xml) {
    console.log('updateXML', xml);
    return this.setState({
      xml: xml
    });
  },
  render: function() {
    return div({
      className: 'app'
    }, [h1({}, "Strava Split"), this.state.xml == null ? FileInput(this.state) : void 0, this.state.xml != null ? GPXView(this.state) : void 0, this.state.cutoff != null ? DownloadLinks(this.state) : void 0]);
  }
});

FileInput = React.createClass({
  getInitialState: function() {
    return {
      over: false
    };
  },
  handleFile: function(e) {
    var files, reader;
    e.preventDefault();
    reader = new FileReader();
    reader.onload = (function(_this) {
      return function(evt) {
        var parser, xml;
        parser = new DOMParser();
        xml = parser.parseFromString(evt.target.result, 'text/xml');
        return _this.props.updateXML(xml);
      };
    })(this);
    files = e.target.files || e.dataTransfer.files;
    return reader.readAsText(files[0]);
  },
  timeout: null,
  handleOver: function(e) {
    e.preventDefault();
    if (!this.state.over) {
      this.setState({
        over: true
      });
    }
    clearTimeout(this.timeout);
    return this.timeout = setTimeout(((function(_this) {
      return function() {
        return _this.setState({
          over: false
        });
      };
    })(this)), 200);
  },
  componentWillUnmount: function() {
    return clearTimeout(this.timeout);
  },
  render: function() {
    return div({
      className: 'fileInput' + (this.state.over ? " over" : ""),
      onDrop: this.handleFile,
      onDragOver: this.handleOver
    }, [
      p({}, "Upload a gpx file"), form({}, input({
        type: 'file',
        onChange: this.handleFile
      }))
    ]);
  }
});

GPXView = React.createClass({
  getInitialState: function() {
    return {
      dividerX: 300
    };
  },
  render: function() {
    var data, ele, hr, i, maxEle, maxHR, maxTime, name, point, timestamp, trkpts, _i, _ref1, _ref2;
    this.start = Date.parse(this.props.xml.querySelector('trkseg trkpt:first-child time').innerHTML);
    this.end = Date.parse(this.props.xml.querySelector('trkseg trkpt:last-child time').innerHTML);
    data = {};
    trkpts = this.props.xml.getElementsByTagName('trkpt');
    _ref1 = [-Infinity, -Infinity, -Infinity], maxEle = _ref1[0], maxHR = _ref1[1], maxTime = _ref1[2];
    for (i = _i = 0, _ref2 = trkpts.length - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
      point = trkpts[i];
      timestamp = Date.parse(point.getElementsByTagName('time')[0].innerHTML);
      data[timestamp - this.start] = {
        lat: point.getAttribute('lat'),
        lon: point.getAttribute('lon'),
        ele: ele = point.getElementsByTagName('ele')[0].innerHTML,
        hr: hr = point.getElementsByTagName('hr')[0].innerHTML
      };
      maxEle = Math.max(maxEle, ele);
      maxHR = Math.max(maxHR, hr);
      maxTime = Math.max(maxTime, timestamp);
    }
    name = this.props.xml.querySelector('name').innerHTML;
    return div({
      className: 'GPXView'
    }, [
      h2({}, name), svg({
        height: 250,
        width: 800,
        onMouseMove: this.handleMove,
        onMouseLeave: this.handleLeave,
        onClick: this.onClick,
        ref: 'svg'
      }, [
        HRLine({
          maxTime: maxTime,
          maxHR: maxHR,
          start: this.start,
          data: data
        }), EleView({
          maxTime: maxTime,
          maxEle: maxEle,
          start: this.start,
          data: data
        }), Divider({
          start: this.start,
          end: this.end,
          cutoff: this.props.cutoff,
          dividerX: this.state.dividerX
        })
      ])
    ]);
  },
  handleMove: function(e) {
    rect = this.refs.svg.getDOMNode().getBoundingClientRect();
    return this.setState({
      dividerX: e.clientX - rect.left
    });
  },
  handleLeave: function(e) {
    return this.setState({
      dividerX: null
    });
  },
  onClick: function(e) {
    var c;
    c = this.state.dividerX * (this.end - this.start) / 800 + this.start;
    return this.props.updateCutoff(c);
  }
});

Divider = React.createClass({
  render: function() {
    var cutoffX;
    return g({}, [
      this.props.cutoff != null ? (cutoffX = (this.props.cutoff - this.props.start) * (800 / (this.props.end - this.props.start)), path({
        className: 'cutoff',
        d: "M " + cutoffX + " 0 " + cutoffX + " 250"
      })) : null, this.props.dividerX != null ? path({
        className: 'cursor',
        d: "M " + this.props.dividerX + " 0 " + this.props.dividerX + " 250"
      }) : null
    ]);
  }
});

EleView = React.createClass({
  render: function() {
    var duration, elePath, obj, sfx, sfy, t;
    duration = this.props.maxTime - this.props.start;
    sfx = 800 / duration;
    sfy = this.props.maxEle > 250 ? 250 / this.props.maxEle : 1;
    elePath = ("M 0 " + this.props.data[0].ele + " L ") + ((function() {
      var _ref1, _results;
      _ref1 = this.props.data;
      _results = [];
      for (t in _ref1) {
        obj = _ref1[t];
        _results.push(t * sfx + " " + obj.ele * -sfy);
      }
      return _results;
    }).call(this)).join(' ') + " 800 0 Z";
    return g({
      stroke: 'none',
      fill: 'rgba(0,0,0,0.15)',
      transform: "translate(0,250)"
    }, path({
      d: elePath
    }));
  }
});

HRLine = React.createClass({
  render: function() {
    var duration, hrline, obj, sfx, sfy, t, _ref1;
    duration = this.props.maxTime - this.props.start;
    sfx = 800 / duration;
    sfy = 250 / this.props.maxHR;
    hrline = "M 0 " + this.props.data[0].hr + " L";
    _ref1 = this.props.data;
    for (t in _ref1) {
      obj = _ref1[t];
      hrline += " " + (t * sfx) + " " + (obj.hr * -sfy);
    }
    return g({
      stroke: '#dd0447',
      strokeWidth: '1.5',
      fill: 'none',
      transform: "translate(0,250)"
    }, path({
      d: hrline
    }));
  }
});

DownloadLinks = React.createClass({
  render: function() {
    var blob1, blob2, firstTime, newXMLString1, newXMLString2, serializer, url1, url2, xml1, xml2;
    xml1 = this.props.xml.cloneNode(true);
    xml2 = this.props.xml.cloneNode(true);
    [].forEach.call(xml1.querySelectorAll('trkseg time'), (function(_this) {
      return function(t) {
        if (Date.parse(t.innerHTML) >= _this.props.cutoff) {
          return t.parentNode.remove();
        }
      };
    })(this));
    xml1.querySelector('trk name').innerHTML += " (part 1)";
    [].forEach.call(xml2.querySelectorAll('trkseg time'), (function(_this) {
      return function(t) {
        if (Date.parse(t.innerHTML) < _this.props.cutoff) {
          return t.parentNode.remove();
        }
      };
    })(this));
    xml2.querySelector('trk name').innerHTML += " (part 2)";
    firstTime = xml2.querySelector('trk time').innerHTML;
    xml2.querySelector('metadata time').innerHTML = firstTime;
    serializer = new XMLSerializer();
    newXMLString1 = serializer.serializeToString(xml1);
    blob1 = new Blob([newXMLString1]);
    url1 = window.URL.createObjectURL(blob1);
    newXMLString2 = serializer.serializeToString(xml2);
    newXMLString2 = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" + newXMLString2;
    blob2 = new Blob([newXMLString2]);
    url2 = window.URL.createObjectURL(blob2);
    return div({
      className: 'downloadLinks'
    }, [
      TinySummary({
        xml: xml1,
        url: url1,
        filename: 'part1.gpx'
      }), " ", TinySummary({
        xml: xml2,
        url: url2,
        filename: 'part2.gpx'
      })
    ]);
  }
});

TinySummary = React.createClass({
  render: function() {
    var duration, end, minutes, name, pad, seconds, start;
    start = Date.parse(this.props.xml.querySelector('trkseg trkpt:first-child time').innerHTML);
    end = Date.parse(this.props.xml.querySelector('trkseg trkpt:last-child time').innerHTML);
    name = this.props.xml.querySelector('name').innerHTML;
    duration = end - start;
    seconds = duration / 1000;
    minutes = seconds / 60;
    pad = function(x) {
      if (x < 10) {
        return "0" + x;
      } else {
        return x;
      }
    };
    return p({
      className: 'tinySummary'
    }, [
      span({
        className: 'duration'
      }, Math.floor(minutes) + ":" + pad(seconds % 60)), span({
        className: 'label'
      }, "duration"), a({
        href: this.props.url,
        className: 'dl',
        download: this.props.filename
      }, "Download " + this.props.filename)
    ]);
  }
});
